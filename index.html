<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bog Blog</title>
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <style>
    html,body,#map { height:100%; margin:0; padding:0; font-family:system-ui, Arial, sans-serif; }
    #map { position: absolute; top:0; right:0; bottom:0; left:360px; }
    .sidebar { position:absolute; left:0; top:0; bottom:0; width:360px; padding:14px; box-sizing:border-box; background:#f8f9fb; overflow:auto; border-right:1px solid #e2e6ea; }
    .search { margin-bottom:10px; }
    .filters { margin-bottom:10px; }
    .facility-item { padding:8px; border-bottom:1px solid #eef2f5; cursor:pointer; }
    .facility-item:hover { background:#eef4fa; }
    .popup-sections a { display:block; margin:6px 0; color:#0066cc; cursor:pointer; text-decoration:underline; }
    .modal { display:none; position:fixed; z-index:99999; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.7); align-items:center; justify-content:center; }
    .modal .content { max-width:1000px; max-height:90%; background:#fff; padding:14px; overflow:auto; border-radius:6px; }
    .gallery img{ max-width:180px; margin:8px; border-radius:6px; }
    .close-btn { float:right; cursor:pointer; font-weight:bold; font-size:18px; }
    table.props { border-collapse:collapse; width:100%; margin-bottom:8px }
    table.props th { text-align:left; padding:6px; background:#f1f5f8; width:34%; }
    table.props td { padding:6px; }
    label{display:block;margin-bottom:6px}
    select,input[type=search]{width:100%;padding:8px;margin-bottom:8px;box-sizing:border-box}
    button{cursor:pointer;padding:8px 10px}
    .small { font-size:90%; color:#555 }
    .collapsible { cursor:pointer; padding:8px 6px; margin-bottom:6px; background:#eef2f5; border-radius:4px; }
    .toggle-list { padding:6px 0 12px 0; }
    /* ensure popups are above everything */
    .maplibregl-popup { z-index: 999999 !important; }
  </style>
</head>
<body>
  <div class="sidebar">
    <h2>Bog Blog v0.8</h2>

    <div class="search">
      <input id="searchInput" type="search" placeholder="Search facility, address or section" />
    </div>

    <div class="collapsible" id="propFilterBtn">Property Filter ▾</div>
    <div id="propertyFilter" style="display:none;padding:6px 0 12px 0;" class="small">(filter by property values)</div>

    <div class="collapsible" id="propToggleBtn">Property visibility ▾</div>
    <div id="propertyToggles" class="toggle-list" style="display:none">
      <div class="small">Toggle which properties appear in the facility popup and section modal.</div>
    </div>

    <div>
      <strong>Facilities</strong>
      <div id="facilityList">Loading facilities...</div>
    </div>
    <hr />
  </div>

  <div id="map"></div>

  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="content">
      <span id="closeModal" class="close-btn" role="button" aria-label="Close">✕</span>
      <div id="modalBody"></div>
    </div>
  </div>

<script>
/* ======================================================================
   CONFIG — update these names as needed
   ====================================================================== */
const CONFIG = {
  SHEET_ID: '147YVLFKhpk7s0gtxBVb9w55icdTh3VRpsNpEP3ojesY',
  FACILITIES_SHEET: 'Facilities',
  SECTIONS_SHEET: 'Sections',
  IMAGES_SHEET: 'Images',
  STATIC: {
    facilities: './data/facilities_static.json',
    sections: './data/sections_static.json',
    images: './data/images_static.json'
  }
};

/* ======================================================================
   Helpers: fetch Google Sheets (gviz) and parse to array of objects
   ====================================================================== */
async function fetchSheet(sheetName){
  try{
    const sheetParam = sheetName ? `&sheet=${encodeURIComponent(sheetName)}` : '';
    const url = `https://docs.google.com/spreadsheets/d/${CONFIG.SHEET_ID}/gviz/tq?tqx=out:json${sheetParam}`;
    const res = await fetch(url);
    const text = await res.text();
    const start = text.indexOf('{');
    const end = text.lastIndexOf('}');
    if(start === -1 || end === -1) throw new Error('Unexpected Google response format');
    const jsonText = text.slice(start, end + 1);
    const gv = JSON.parse(jsonText);
    return gvizToObjects(gv);
  }catch(e){
    console.warn('fetchSheet failed for', sheetName, e);
    return [];
  }
}
function gvizToObjects(gv){
  if(!gv || !gv.table) return [];
  const cols = gv.table.cols.map(c => (c.label || c.id || '').toString());
  return gv.table.rows.map(r => {
    const obj = {};
    r.c.forEach((cell, i) => { obj[cols[i]] = cell ? cell.v : null; });
    return obj;
  });
}

/* ======================================================================
   Load data (static + dynamic) and normalize
   ====================================================================== */
async function loadData(){
  const [staticFacilities, staticSections, staticImages] = await Promise.all([
    fetch(CONFIG.STATIC.facilities).then(r=>r.json()).catch(_=>[]),
    fetch(CONFIG.STATIC.sections).then(r=>r.json()).catch(_=>[]),
    fetch(CONFIG.STATIC.images).then(r=>r.json()).catch(_=>[])
  ]);

  const [dynF, dynS, dynI] = await Promise.all([
    fetchSheet(CONFIG.FACILITIES_SHEET),
    fetchSheet(CONFIG.SECTIONS_SHEET),
    fetchSheet(CONFIG.IMAGES_SHEET)
  ]);

  const normalize = arr => arr.map(o => { const copy = {}; Object.keys(o).forEach(k => { copy[k.trim()] = o[k]; }); return copy; });

  const facilities = [...normalize(staticFacilities), ...normalize(dynF)];
  const sections = [...normalize(staticSections), ...normalize(dynS)];
  const images = [...normalize(staticImages), ...normalize(dynI)];

  return { facilities, sections, images };
}

/* ======================================================================
   Build GeoJSON features (clean + consistent property names)
   ====================================================================== */
function buildFeatureCollection({ facilities, sections, images }) {

  /* ---- Normalize section lookup ---- */
  const sectionsByFacility = {};
  sections.forEach(s => {
    const fid = String(
      s.facility_id || s.facility || s.id || s.FacilityID
    ).trim();
    if (!fid) return;

    if (!sectionsByFacility[fid]) sectionsByFacility[fid] = [];
    sectionsByFacility[fid].push({ ...s });
  });

  /* ---- Normalize images lookup (per facility + section) ---- */
  const imagesByFacilitySection = {};
  images.forEach(img => {
    const fid = String(
      img.facility_id || img.facility || img.FacilityID
    ).trim();
    if (!fid) return;

    const sec = String(
      img.section_name || img.section || img.SectionName || "default"
    ).trim();

    if (!imagesByFacilitySection[fid]) imagesByFacilitySection[fid] = {};
    if (!imagesByFacilitySection[fid][sec]) imagesByFacilitySection[fid][sec] = [];

    // store ENTIRE IMAGE OBJECT (not just URL)
    imagesByFacilitySection[fid][sec].push({ ...img });
  });

  /* ---- Build GeoJSON Features ---- */
  const features = facilities.map(f => {
    const fid = String(
      f.facility_id || f.FacilityID || f.id
    ).trim();

    /* ---- Extract safe numeric coordinates ---- */
    const lat = parseFloat(
      (f.lat !== undefined && f.lat !== null && f.lat !== '') ? f.lat : (f.lat_lng && f.lat_lng.split(',')[0])
    );
    const lng = parseFloat(
      (f.lng !== undefined && f.lng !== null && f.lng !== '') ? f.lng : (f.lat_lng && f.lat_lng.split(',')[1])
    );

    if (Number.isNaN(lat) || Number.isNaN(lng)) return null;

    /* ---- Build sections with images ---- */
    const secList = (sectionsByFacility[fid] || []).map(sec => {
      const secName =
        sec.section_name ||
        sec.section ||
        sec.SectionName ||
        "default";

      return {
        ...sec,
        images: imagesByFacilitySection[fid]?.[secName] || []
      };
    });

    /* ---- FINAL consistent properties object ---- */
    const props = {
      facility_id: fid,
      // prefer facility_name; fall back to other possible headers
      facility_name: f.facility_name || f['facility name'] || f.FacilityName || f.facility || f.Facility || 'Unnamed',
      amenity: f.amenity || '',
      country: f.country || '',
      address: f.address || f.Address || '',
      lat,
      lng,
      // preserve all original keys so toggles can find them
      ...f,
      // attach processed sections
      sections: secList
    };

    return {
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: [lng, lat]
      },
      properties: props
    };
  }).filter(Boolean);

  return {
    type: "FeatureCollection",
    features
  };
}

/* ======================================================================
   Initialize MapLibre map
   ====================================================================== */
let currentPopup = null;
const appMap = new maplibregl.Map({
  container: 'map',
  style: {
    version: 8,
    glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
    sources: {
      'osm-tiles': { type: 'raster', tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'], tileSize:256 }
    },
    layers: [{ id:'osm-tiles', type:'raster', source:'osm-tiles' }]
  },
  center: [0,20],
  zoom: 2
});

/* ======================================================================
   Centralized handler to open popup + flyTo (robust)
   ====================================================================== */
function handleMapFeatureClick(feature) {
  if(!feature) return;

  // Close previous popup
  if (currentPopup) {
    try { currentPopup.remove(); } catch (e) {}
    currentPopup = null;
  }

  // Determine coordinates robustly
  let coords = null;
  if (feature.geometry && feature.geometry.coordinates) coords = feature.geometry.coordinates;
  else if (feature._geometry && feature._geometry.coordinates) coords = feature._geometry.coordinates;
  else if (feature.properties && feature.properties.lng && feature.properties.lat) coords = [parseFloat(feature.properties.lng), parseFloat(feature.properties.lat)];
  else if (feature.properties && feature.properties.longitude && feature.properties.latitude) coords = [parseFloat(feature.properties.longitude), parseFloat(feature.properties.latitude)];

  if (!coords) {
    console.warn('No coordinates for feature', feature);
    return;
  }

  // Fly there
  appMap.flyTo({ center: coords, zoom: 16 });

  // Build popup content and show it
  const container = createFacilityPopupContent(feature);
  // debug: ensure non-empty container
  // console.log('popup container html', container && container.innerHTML);

  currentPopup = new maplibregl.Popup()
    .setLngLat(coords)
    .setDOMContent(container)
    .addTo(appMap);
}

/* ======================================================================
   Map load: fetch data and add source/layers (idempotent)
   ====================================================================== */
appMap.on('load', async () => {
  try {
    const data = await loadData();
    const geojson = buildFeatureCollection(data);
    window.__MAP_DATA = { raw: geojson, facilities: data.facilities, sections: data.sections, images: data.images };

    // SAFE source add/update
    if (appMap.getSource('toilets')) {
      appMap.addSource('toilets', { type:'geojson', data: geojson, cluster: false });
    } else {
      appMap.getSource('toilets').setData(geojson);
    }

    // SAFE layer add
    if (appMap.getLayer('toilet-points')) {
      appMap.addLayer({
        id: 'toilet-points',
        type: 'circle',
        source: 'toilets',
        paint: {
          'circle-radius': 6,
          'circle-color': '#1f78b4',
          'circle-stroke-width': 1
        }
      });
    }

    if (appMap.getLayer('toilet-labels')) {
      appMap.addLayer({
        id: 'toilet-labels',
        type: 'symbol',
        source: 'toilets',
        layout: {
          'text-field': ['get', 'facility_name'],
          'text-offset': [0, 1.2],
          'text-size': 12,
          'text-ignore-placement': false,
          'text-allow-overlap': false
        }
      });
    }

    // Build sidebar and UI
    buildFacilityList(geojson.features);
    buildFacilityFilters(data.facilities, data.sections, data.images);
    setupPropertyToggles({facilities:data.facilities, sections:data.sections, images:data.images});

    // click handlers (both layers)
    appMap.on('click','toilet-points', e => {
      const feature = e.features && e.features[0];
      handleMapFeatureClick(feature);
    });
    appMap.on('click','toilet-labels', e => {
      const feature = e.features && e.features[0];
      handleMapFeatureClick(feature);
    });

    // fallback: query features at click point
    appMap.on('click', (e) => {
      const hits = map.queryRenderedFeatures(e.point, { layers: ['toilet-points','toilet-labels'] });
      if (hits && hits.length) handleMapFeatureClick(hits[0]);
    });

    appMap.on('mouseenter','toilet-points', ()=> map.getCanvas().style.cursor='pointer');
    appMap.on('mouseleave','toilet-points', ()=> map.getCanvas().style.cursor='');

  } catch(err) {
    console.error('Boot failed', err);
    document.getElementById('facilityList').textContent='Failed to load data. Check console.';
  }
});

/* ======================================================================
   Facility list builder
   ====================================================================== */
function buildFacilityList(features){
  const list = document.getElementById('facilityList'); list.innerHTML = '';
  features.forEach(f => {
    const d = document.createElement('div'); d.className='facility-item';
    const name = f.properties.facility_name || f.properties.facility || f.properties.FacilityName || 'Unnamed';
    const addr = f.properties.address || f.properties.Address || '';
    d.innerHTML = `<strong>${escapeHtml(name)}</strong><div class="small">${escapeHtml(addr)}</div>`;
    d.addEventListener('click', ()=>{
      if(currentPopup){ try{ currentPopup.remove(); }catch(e){} currentPopup=null; }
      handleMapFeatureClick(f);
    });
    list.appendChild(d);
  });
}

/* ======================================================================
   Property filter builder (collapsed).
   Exclude amenity & address; include extra keys from sections/images.
   ====================================================================== */
function buildFacilityFilters(facilities, sections, images){
  const container = document.getElementById('propertyFilter'); container.innerHTML='';
  const exclude = new Set(['facility_id','id','lat','lng','latitude','longitude','lat_lng','amenity','address','Address','Facility','facility']);

  // gather candidate keys from facilities
  const sample = facilities[0] || {};
  const keys = Object.keys(sample).filter(k => !exclude.has(k));

  // also include specific keys from sections/images
  const extraKeys = ['access','type','image_taken','photo_taken','image_date'];
  extraKeys.forEach(k=>{ if(!keys.includes(k)) keys.push(k); });

  if(!keys.length){ container.textContent='(no filterable properties)'; return; }

  // create collapsible UI
  const wrapper = document.createElement('div');
  keys.forEach(k => {
    // collect unique values from facilities + sections + images
    const vals = new Set();
    facilities.forEach(f => { const v=f[k]; if(v!==null && v!==undefined && v!=='') vals.add(String(v)); });
    sections.forEach(s => { const v=s[k] || s[k.toLowerCase()]; if(v!==null && v!==undefined && v!=='') vals.add(String(v)); });
    images.forEach(i => { const v=i[k] || i[k.toLowerCase()]; if(v!==null && v!==undefined && v!=='') vals.add(String(v)); });
    if(vals.size<=0) return;
    const lbl = document.createElement('label');
    lbl.innerHTML = `${escapeHtml(k)}<select data-col="${escapeHtml(k)}"><option value="">All</option></select>`;
    const sel = lbl.querySelector('select');
    Array.from(vals).sort().forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); });
    wrapper.appendChild(lbl);
    sel.addEventListener('change', applyFilters);
  });

  container.appendChild(wrapper);

  // collapse/expand
  const btn = document.getElementById('propFilterBtn');
  btn.addEventListener('click', ()=>{ container.style.display = container.style.display === 'none' ? 'block' : 'none'; });
  // start collapsed
  container.style.display = 'none';
}

function getActiveFilters(){
  const selects = document.querySelectorAll('#propertyFilter select');
  const filters = {};
  selects.forEach(s => { if(s.value) filters[s.dataset.col]=s.value; });
  return filters;
}

function applyFilters(){
  const filters = getActiveFilters();
  const raw = window.__MAP_DATA.raw.features;
  const filtered = raw.filter(feat => {
    const props = feat.properties;
    for(const k in filters){
      // check facility prop, then check sections/images
      const v = String(props[k]||'');
      if(v === String(filters[k])) continue;
      // check sections
      const secMatch = (props.sections||[]).some(s => String(s[k]||s[k.toLowerCase()]||'') === String(filters[k]));
      if(secMatch) continue;
      // no match
      return false;
    }
    return true;
  });
  const fc = { type:'FeatureCollection', features: filtered };
  if(map.getSource('toilets')) map.getSource('toilets').setData(fc);
  buildFacilityList(filtered);
}

/* ======================================================================
   Property visibility toggles (gathers keys from facilities, sections, images)
   ====================================================================== */
const DEFAULT_VISIBLE = ['amenity','country','description'];
function setupPropertyToggles(data){
  const container = document.getElementById('propertyToggles'); container.innerHTML='';
  const facilities = data.facilities || [];
  const sections = data.sections || [];
  const images = data.images || [];
  if(!facilities.length){ container.innerHTML='<div class="small">(no properties)</div>'; return; }

  const ex = new Set(['facility_id','id','lat','lng','latitude','longitude','lat_lng','sections','SectionID','FacilityID']);

  const facKeys = Object.keys(facilities[0]).filter(k => !ex.has(k));
  const secKeys = Object.keys(sections[0]||{}).filter(k => !ex.has(k));
  const imgKeys = Object.keys(images[0]||{}).filter(k => !ex.has(k));

  // Helper to build group
  function buildGroup(title, keys, source){
    const h = document.createElement('div');
    h.innerHTML = `<strong>${escapeHtml(title)}</strong>`;
    container.appendChild(h);
    keys.forEach(k => {
      const id = `${source}_prop_` + k.replace(/[^a-z0-9_\-]/gi,'_');
      const checked = DEFAULT_VISIBLE.includes(k.toLowerCase()) || (source==='image' && ['image_taken','image_date','photo_taken'].includes(k.toLowerCase())) ? 'checked' : '';
      const div = document.createElement('div');
      div.innerHTML = `<input type="checkbox" id="${id}" data-prop="${escapeHtml(k)}" data-source="${source}" ${checked}><label for="${id}">${escapeHtml(k)}</label>`;
      container.appendChild(div);
    });
  }

  if(facKeys.length) buildGroup('Facility properties', facKeys, 'facility');
  if(secKeys.length) buildGroup('Section properties', secKeys, 'section');
  if(imgKeys.length) buildGroup('Image properties', imgKeys, 'image');

  // toggle collapse
  const btn = document.getElementById('propToggleBtn');
  btn.addEventListener('click', () => {
    const el = document.getElementById('propertyToggles');
    el.style.display = (el.style.display === 'block') ? 'none' : 'block';
  });
}

function getVisibleProperties(){
  const checks = Array.from(document.querySelectorAll('#propertyToggles input[type=checkbox]'));
  const out = { facility: [], section: [], image: [] };
  checks.forEach(c => { if(c.checked){ const s = c.dataset.source || 'facility'; out[s].push(c.dataset.prop); } });
  return out;
}

/* ======================================================================
   Facility popup builder (returns DOM container). Does NOT directly add popup
   so caller can control opening/closing and store the popup object.
   ====================================================================== */
function createFacilityPopupContent(feature){
  const props = feature.properties || {};

  // ensure facility_id exists for later section lookup
  props.facility_id = props.facility_id || props.FacilityID || props.id || props.ID || '';

  const facilityName = props.facility_name || props.facility || props.FacilityName || 'Unnamed';
  const addr = props.address || props.Address || '';
  const visible = getVisibleProperties();

  const container = document.createElement('div');
  let html = '';
  html += `<strong>${escapeHtml(facilityName)}</strong>`;
  if(addr) html += `<div class="small">${escapeHtml(addr)}</div>`;

  // facility properties
  html += `<table class="props">`;
  Object.keys(props).forEach(k => {
    if(['lat','lng','latitude','longitude','lat_lng','sections','facility_id','FacilityID'].includes(k)) return;
    if(visible.facility.length && visible.facility.indexOf(k) === -1) return;
    const v = props[k];
    if(v===null||v===undefined||v==='') return;
    const val = Array.isArray(v) ? v.join(', ') : String(v);
    html += `<tr><th>${escapeHtml(k)}</th><td>${escapeHtml(val)}</td></tr>`;
  });
  html += `</table>`;

  // sections list
  const secs = props.sections || [];
  html += `<div><strong>Sections</strong>`;
  if(!secs.length) html += `<div class="small">(no sections)</div>`;
  html += `<ul class="small">`;
  secs.forEach(s => {
    const secName = s.section_name || s.section || s.sectionName || 'default';
    html += `<li><a href="#" class="sec-link" data-fid="${escapeHtml(props.facility_id)}" data-sec="${escapeHtml(secName)}">${escapeHtml(secName)}</a></li>`;
  });
  html += `</ul></div>`;

  container.innerHTML = html;

  // attach handlers
  container.querySelectorAll('.sec-link').forEach(a => {
    a.addEventListener('click', e => {
      e.preventDefault();
      const fid = a.dataset.fid;
      const sec = a.dataset.sec;
      openSectionModal(fid, sec);
    });
  });

  return container;
}

/* ======================================================================
   Section modal: shows section properties, image-level properties and gallery
   ====================================================================== */
function openSectionModal(facilityId, sectionName){
  const modal = document.getElementById('modal');
  const body = document.getElementById('modalBody');
  const data = window.__MAP_DATA;
  const facility = data.facilities.find(f => String(f.facility_id||f.id||f.FacilityID||f.facility||f.Facility) === String(facilityId));
  const section = data.sections.find(s => String(s.facility_id||s.facility||s.id||s.SectionID) === String(facilityId) && String(s.section_name||s.section||s.sectionName||s.SectionName) === String(sectionName));
  const imgs = data.images.filter(i => String(i.facility_id||i.facility||i.id||i.FacilityID) === String(facilityId) && String(i.section_name||i.section||i.sectionName||i.SectionName||'') === String(sectionName));
  const visible = getVisibleProperties();

  let html = '';
  html += `<h3>${escapeHtml(sectionName)}</h3>`;
  if(section && (section.description || section.Description)) html += `<p>${escapeHtml(section.description || section.Description)}</p>`;

  // section properties
  if(section){
    html += `<table class="props">`;
    Object.keys(section).forEach(k => {
      if(['facility_id','section_name','section','id','image_url','SectionID'].includes(k)) return;
      if(visible.section.length && visible.section.indexOf(k) === -1) return;
      const v = section[k];
      if(v===null||v===undefined||v==='') return;
      html += `<tr><th>${escapeHtml(k)}</th><td>${escapeHtml(String(v))}</td></tr>`;
    });
    html += `</table>`;
  }

  // image-level aggregated properties (e.g., image_taken)
  if(imgs.length){
    const imgProps = visible.image.length ? visible.image : ['image_taken','image_date','photo_taken','URL'];
    // collect unique values per prop
    const aggregates = {};
    imgProps.forEach(p => { aggregates[p] = new Set(); });
    imgs.forEach(img => {
      imgProps.forEach(p => {
        const val = img[p] || img[p.toLowerCase()] || img[p.toUpperCase()];
        if(val!==null && val!==undefined && val!=='') aggregates[p].add(String(val));
      });
    });
    // render table of image-level props
    html += `<table class="props">`;
    Object.keys(aggregates).forEach(p => {
      const vals = Array.from(aggregates[p]);
      if(!vals.length) return;
      html += `<tr><th>${escapeHtml(p)}</th><td>${escapeHtml(vals.join(', '))}</td></tr>`;
    });
    html += `</table>`;
  }

  // gallery
  if(imgs.length){
    html += `<div class="gallery">`;
    imgs.forEach(u => { const src = u.image_url || u.URL || u.url; html += `<img src="${escapeHtml(src)}" alt=""/>`; });
    html += `</div>`;
  } else {
    html += `<div class="small">No images found for this section.</div>`;
  }

  body.innerHTML = html;
  modal.style.display = 'flex';
}

document.getElementById('closeModal').addEventListener('click', ()=>{ document.getElementById('modal').style.display='none'; });

/* ======================================================================
   Helpers
   ====================================================================== */
function escapeHtml(s){ if(s===null||s===undefined) return ''; return String(s).replace(/[&"'<>]/g, c=>({'&':'&amp;','"':'&quot;',"'":"&#39;","<":"&lt;",">":"&gt;"}[c])); }

/* ======================================================================
   Boot: initial load and UI hookup (keeps idempotence)
   ====================================================================== */
(async function(){
  try{
    const dataRaw = await loadData();
    const geojson = buildFeatureCollection(dataRaw);
    window.__MAP_DATA = { raw: geojson, facilities: dataRaw.facilities, sections: dataRaw.sections, images: dataRaw.images };

    if(map.getSource('toilets')) map.getSource('toilets').setData(geojson);
    else appMap.addSource('toilets', { type:'geojson', data: geojson });

    if(!map.getLayer('toilet-points')) appMap.addLayer({ id: 'toilet-points', type:'circle', source:'toilets', paint: { 'circle-radius':6, 'circle-color':'#1f78b4', 'circle-stroke-width':1 } });
    if(!map.getLayer('toilet-labels')) map.addLayer({ id:'toilet-labels', type:'symbol', source:'toilets', layout:{ 'text-field':['get','facility_name'] , 'text-offset':[0,1.2], 'text-size':12 } });

    buildFacilityList(geojson.features);
    buildFacilityFilters(dataRaw.facilities, dataRaw.sections, dataRaw.images);
    setupPropertyToggles({facilities:dataRaw.facilities, sections:dataRaw.sections, images:dataRaw.images});
  } catch(err){ console.error('Boot failed', err); document.getElementById('facilityList').textContent='Failed to load data. Check console.'; }
})();
</script>
</body>
</html>





